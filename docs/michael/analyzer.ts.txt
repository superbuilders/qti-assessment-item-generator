/**
 * Pedagogical Analyzer
 * Uses Gemini 2.5 Pro to extract comprehensive pedagogical understanding from math problems
 */

import { GoogleGenerativeAI } from '@google/generative-ai';
import { 
  PedagogicalAnalysis, 
  ProblemMetadata,
  VariableDefinition,
  PedagogicalTechnique,
  DistractorAnalysis
} from './types';
import { MarkdownParser } from './markdown-parser';

export class PedagogicalAnalyzer {
  private genAI: GoogleGenerativeAI;
  private model: any;

  constructor(apiKey: string) {
    this.genAI = new GoogleGenerativeAI(apiKey);
    this.model = this.genAI.getGenerativeModel({ 
      model: "gemini-2.5-pro",
      generationConfig: {
        temperature: 0.2,
        topK: 1,
        topP: 0.95,
        maxOutputTokens: 8192,
      }
    });
  }

  async analyzeProblem(
    problemHTML: string, 
    problemImage?: string,
    additionalContext?: string
  ): Promise<PedagogicalAnalysis> {
    const prompt = this.constructAnalysisPrompt(problemHTML, additionalContext);
    
    try {
      let result;
      
      if (problemImage) {
        // If we have an image, include it in the analysis
        const imagePart = {
          inlineData: {
            mimeType: "image/png",
            data: problemImage.split(',')[1] // Remove data:image/png;base64, prefix
          }
        };
        
        result = await this.model.generateContent([prompt, imagePart]);
      } else {
        result = await this.model.generateContent(prompt);
      }
      
      const response = await result.response;
      const rawMarkdown = response.text();
      
      // Parse the markdown into structured data
      let analysis: PedagogicalAnalysis;
      try {
        analysis = MarkdownParser.parseAnalysis(rawMarkdown);
      } catch (parseError) {
        console.warn('Failed to parse markdown, falling back to basic analysis:', parseError);
        analysis = this.createBasicAnalysis(rawMarkdown, problemHTML);
      }

      return analysis;
    } catch (error) {
      console.error('Error analyzing problem:', error);
      throw new Error(`Failed to analyze problem: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  // Create a basic analysis structure from the markdown
  private createBasicAnalysis(markdown: string, problemHTML: string): PedagogicalAnalysis {
    // Extract basic information from the markdown
    const titleMatch = markdown.match(/Title:\s*(.+)/i);
    const topicMatch = markdown.match(/Topic:\s*(.+)/i);
    const gradeMatch = markdown.match(/Grade Level:\s*(\d+)/i);
    const difficultyMatch = markdown.match(/Difficulty:\s*(\w+)/i);
    const problemTypeMatch = markdown.match(/Problem Type:\s*(.+)/i);
    
    return {
      metadata: {
        title: titleMatch ? titleMatch[1].trim() : 'Untitled Problem',
        topic: topicMatch ? topicMatch[1].trim() : 'Mathematics',
        subTopic: '',
        gradeLevel: gradeMatch ? parseInt(gradeMatch[1]) : 5,
        difficulty: (difficultyMatch ? difficultyMatch[1].toLowerCase() : 'medium') as any,
        skills: [],
        prerequisites: [],
        estimatedTime: 5,
        problemType: problemTypeMatch ? problemTypeMatch[1].trim() : 'multiple-choice'
      },
      structure: {
        questionText: this.extractQuestionText(problemHTML),
        questionType: 'multiple-choice',
        correctAnswer: '',
        answerFormat: 'visual-selection',
        scoringRubric: []
      },
      variables: {
        independent: [],
        dependent: [],
        constraints: [],
        relationships: []
      },
      pedagogicalTechniques: [],
      presentationFlow: [],
      distractorAnalysis: {
        distractors: [],
        commonMisconceptions: [],
        differentiationStrategy: ''
      },
      visualElements: [],
      languagePatterns: []
    };
  }

  private extractQuestionText(html: string): string {
    // Simple extraction of question text from HTML
    const match = html.match(/<p>([^<]+)<\/p>/);
    return match ? match[1].trim() : '';
  }

  // Keep the old method for backward compatibility
  analyzeProblemLegacy(
    problemHTML: string, 
    problemImage?: string,
    additionalContext?: string
  ): Promise<PedagogicalAnalysis> {
    return this.analyzeProblem(problemHTML, problemImage, additionalContext);
  }

  private constructAnalysisPrompt(problemHTML: string, additionalContext?: string): string {
    return `You are an expert mathematics educator and instructional designer. Analyze the following math problem to extract its complete pedagogical structure and educational value.

IMPORTANT: This analysis should be SPECIFIC to this exact problem format. The template generated from this analysis should reproduce problems that look EXACTLY like this one, with the same structure, wording patterns, and presentation style. Do NOT generalize beyond what is shown.

MATHEMATICAL NOTATION GUIDELINES:
1. Use simple notation for most mathematical content:
   - Variable names: factor1, factor2, product (or use backticks: \`factor1\`)
   - Simple numbers: 2, 12, 100
   - Basic operations: +, -, ×, ÷, =
   - Simple expressions: factor1 × factor2 = product

2. Use MathML ONLY for complex expressions where precision matters:
   - Fractions: <math xmlns="http://www.w3.org/1998/Math/MathML"><mfrac><mn>3</mn><mn>4</mn></mfrac></math>
   - Exponents: <math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mn>3</mn></msup></math>
   - Square roots: <math xmlns="http://www.w3.org/1998/Math/MathML"><msqrt><mn>16</mn></msqrt></math>
   - Complex layouts that can't be expressed clearly in plain text

3. The goal is readable documentation that precisely describes the mathematics without unnecessary verbosity.

## Math Problem HTML:
\`\`\`html
${problemHTML}
\`\`\`

${additionalContext ? `## Additional Context:\n${additionalContext}\n` : ''}

Please provide a comprehensive analysis in the following markdown format:

# Pedagogical Analysis

## Problem Metadata
- **Title**: [Descriptive title for the problem]
- **Topic**: [Main mathematical topic]
- **Sub-topic**: [Specific skill or concept]
- **Grade Level**: [Appropriate grade level]
- **Difficulty**: [easy/medium/hard]
- **Skills Required**: [List of prerequisite skills]
- **Estimated Time**: [Time in minutes]
- **Problem Type**: [e.g., line-plot-construction, fraction-addition]

## Problem Structure
- **Question Text**: [The main question being asked]
- **Question Type**: [multiple-choice/constructed-response/interactive]
- **Correct Answer**: [The correct answer]
- **Answer Format**: [How the answer should be presented]

## Variable System

### Independent Variables
[For each independent variable, provide:]
- **Name**: [variable name]
- **Type**: [fraction/integer/decimal/expression/visual/text]
- **Description**: [What this variable represents]
- **Range/Values**: [Valid range or set of values]
- **Generation Strategy**: [random/systematic/pedagogical]
- **Pedagogical Purpose**: [Why this variable matters educationally]

### Dependent Variables
[For each dependent variable, provide:]
- **Name**: [variable name]
- **Type**: [data type]
- **Description**: [What this represents]
- **Derivation**: [How it's calculated from independent variables]
- **Pedagogical Purpose**: [Educational significance]

### Constraints
[List all constraints:]
- **Type**: [mathematical/pedagogical/visual/complexity]
- **Description**: [What the constraint ensures]
- **Expression**: [Mathematical or logical expression]
- **Variables Involved**: [Which variables this constraint affects]

## Pedagogical Techniques

[For each technique used:]
### Technique Name
- **Category**: [cognitive/visual/linguistic/structural]
- **Description**: [What the technique is]
- **Implementation**: [How it's implemented in this problem]
- **Effectiveness**: [Why it works for student learning]

## Presentation Flow

[For each step in the problem presentation:]
### Step [Number]: [Purpose]
- **Content**: [What is presented]
- **Math Elements**: [Mathematical expressions or visuals]
- **Visual Aids**: [Diagrams, colors, highlighting]
- **Cognitive Load**: [low/medium/high]
- **Prerequisites**: [Which previous steps are required]

## Worked Example

### Complete Solution Steps
[Provide a detailed, step-by-step worked example that shows how to solve the problem correctly:]
- **Step 1**: [First step with clear explanation]
  - Mathematical work: [Show the actual calculation]
  - Reasoning: [Why this step is necessary]
- **Step 2**: [Second step]
  - Mathematical work: [Show the calculation]
  - Reasoning: [Explanation]
[Continue for all steps...]

### Key Solution Elements
- **Critical Insights**: [Important realizations needed to solve]
- **Common Pitfalls**: [Where students typically go wrong]
- **Verification Method**: [How to check the answer]

### Presentation Style
- **Formatting**: [How mathematical work should be displayed]
- **Visual Cues**: [Colors, highlighting, indentation patterns]
- **Step Separation**: [How to clearly delineate steps]

## Distractor Analysis

### Distractors
[For each multiple choice option that is incorrect:]
- **Option**: [A/B/C/D/E]
- **Value**: [The incorrect answer]
- **Target Misconception**: [What error this represents]
- **Generation Rule**: [How to generate similar distractors]
- **Plausibility**: [low/medium/high]

### Feedback Structure
[For each distractor:]
- **Option [Letter]**:
  - **Immediate Feedback**: [Quick correction]
  - **Explanation**: [Why this is incorrect]
  - **Remedial Steps**: [How to correct the thinking]
  - **Next Steps**: [What to study or practice]

## Visual Elements
[Describe all visual components:]
- **Element**: [Name/ID]
- **Type**: [diagram/chart/animation/interactive]
- **Purpose**: [Educational goal]
- **Data Binding**: [Which variables it represents]
- **Design Principles**: [Why it's designed this way]

## Language Patterns
[Identify key language patterns:]
- **Instructions**: [How directions are given]
- **Transitions**: [How steps connect]
- **Explanations**: [How concepts are explained]
- **Feedback**: [How corrections are communicated]

## Common Misconceptions
[List potential student errors:]
- **Misconception**: [Description]
- **Error Pattern**: [How students make this mistake]
- **Detection**: [How to identify if a student has this misconception]
- **Remediation**: [How to correct it]

## Accessibility Considerations
- **Visual**: [How to make visuals accessible]
- **Language**: [Simplification strategies]
- **Cognitive**: [Reducing unnecessary complexity]
- **Technical**: [Digital accessibility features]

Provide a thorough analysis that captures all pedagogical nuances and can be used to generate similar problems programmatically.`;
  }

  private parseAnalysisResponse(markdownText: string): PedagogicalAnalysis {
    // This is a simplified parser - in production, you'd want a more robust markdown parser
    // For now, we'll create a basic structure
    
    const sections = this.extractSections(markdownText);
    
    return {
      metadata: this.parseMetadata(sections['Problem Metadata'] || ''),
      structure: this.parseStructure(sections['Problem Structure'] || ''),
      variables: this.parseVariables(sections['Variable System'] || ''),
      pedagogicalTechniques: this.parseTechniques(sections['Pedagogical Techniques'] || ''),
      presentationFlow: this.parsePresentationFlow(sections['Presentation Flow'] || ''),
      distractorAnalysis: this.parseDistractors(sections['Distractor Analysis'] || ''),
      visualElements: this.parseVisualElements(sections['Visual Elements'] || ''),
      languagePatterns: this.parseLanguagePatterns(sections['Language Patterns'] || '')
    };
  }

  private extractSections(markdown: string): Record<string, string> {
    const sections: Record<string, string> = {};
    const lines = markdown.split('\n');
    let currentSection = '';
    let sectionContent: string[] = [];
    
    for (const line of lines) {
      if (line.startsWith('## ')) {
        if (currentSection) {
          sections[currentSection] = sectionContent.join('\n');
        }
        currentSection = line.substring(3).trim();
        sectionContent = [];
      } else {
        sectionContent.push(line);
      }
    }
    
    if (currentSection) {
      sections[currentSection] = sectionContent.join('\n');
    }
    
    return sections;
  }

  private parseMetadata(section: string): ProblemMetadata {
    const extractValue = (key: string): string => {
      const regex = new RegExp(`\\*\\*${key}\\*\\*:\\s*(.+)`, 'i');
      const match = section.match(regex);
      return match ? match[1].trim() : '';
    };

    const extractList = (key: string): string[] => {
      const value = extractValue(key);
      return value ? value.split(',').map(s => s.trim()).filter(s => s) : [];
    };

    return {
      title: extractValue('Title'),
      topic: extractValue('Topic'),
      subTopic: extractValue('Sub-topic'),
      gradeLevel: parseInt(extractValue('Grade Level')) || 5,
      difficulty: (extractValue('Difficulty') as any) || 'medium',
      skills: extractList('Skills Required'),
      prerequisites: extractList('Prerequisites'),
      estimatedTime: parseInt(extractValue('Estimated Time')) || 10,
      problemType: extractValue('Problem Type')
    };
  }

  private parseStructure(section: string): any {
    // Similar parsing logic for other sections
    // This is a placeholder - implement full parsing based on your needs
    return {
      questionText: '',
      questionType: 'multiple-choice',
      correctAnswer: '',
      answerFormat: '',
      scoringRubric: []
    };
  }

  private parseVariables(section: string): any {
    // Parse independent and dependent variables
    return {
      independent: [],
      dependent: [],
      constraints: [],
      relationships: []
    };
  }

  private parseTechniques(section: string): PedagogicalTechnique[] {
    // Parse pedagogical techniques
    return [];
  }

  private parsePresentationFlow(section: string): any[] {
    // Parse presentation steps
    return [];
  }

  private parseDistractors(section: string): DistractorAnalysis {
    // Parse distractor analysis
    return {
      distractors: [],
      commonMisconceptions: [],
      differentiationStrategy: ''
    };
  }

  private parseVisualElements(section: string): any[] {
    // Parse visual elements
    return [];
  }

  private parseLanguagePatterns(section: string): any[] {
    // Parse language patterns
    return [];
  }

  /**
   * Generates a markdown report from the analysis
   */
  generateMarkdownReport(analysis: PedagogicalAnalysis): string {
    return `# Pedagogical Analysis Report

## Problem Metadata
- **Title**: ${analysis.metadata.title}
- **Topic**: ${analysis.metadata.topic}
- **Grade Level**: ${analysis.metadata.gradeLevel}
- **Difficulty**: ${analysis.metadata.difficulty}
- **Problem Type**: ${analysis.metadata.problemType}

## Variable System
${this.formatVariableSystem(analysis.variables)}

## Pedagogical Techniques
${analysis.pedagogicalTechniques.map(t => `
### ${t.name}
- **Category**: ${t.category}
- **Description**: ${t.description}
- **Implementation**: ${t.implementation}
`).join('\n')}

## Presentation Flow
${analysis.presentationFlow.map(step => `
### Step ${step.stepNumber}: ${step.purpose}
- **Content**: ${step.content.text}
- **Cognitive Load**: ${step.cognitiveLoad}
`).join('\n')}

## Distractor Analysis
${this.formatDistractorAnalysis(analysis.distractorAnalysis)}
`;
  }

  private formatVariableSystem(variables: any): string {
    return `
### Independent Variables
${variables.independent.map((v: VariableDefinition) => `
- **${v.name}** (${v.type}): ${v.description}
  - Purpose: ${v.pedagogicalPurpose}
`).join('\n')}

### Dependent Variables
${variables.dependent.map((v: VariableDefinition) => `
- **${v.name}** (${v.type}): ${v.description}
`).join('\n')}
`;
  }

  private formatDistractorAnalysis(analysis: DistractorAnalysis): string {
    return analysis.distractors.map(d => `
### Option ${d.id}
- **Value**: ${d.value}
- **Targets**: ${d.targetMisconception}
- **Feedback**: ${d.feedback.explanation}
`).join('\n');
  }
} 